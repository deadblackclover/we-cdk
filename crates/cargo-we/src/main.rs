use cargo_metadata::Message;
use clap::{Args, Parser, Subcommand};
use std::{
    env, fs,
    io::{Error, Write},
    path::{Path, PathBuf},
    process::{Command, Stdio},
};

#[derive(Debug, Parser)]
#[command(author, version, about, long_about = None)]
enum Cli {
    /// Toolkit for development WASM smart-contracts.
    #[clap(name = "we")]
    We(WeArgs),
}

#[derive(Args, Debug)]
struct WeArgs {
    #[clap(subcommand)]
    action: Action,
}

#[derive(Debug, Subcommand)]
enum Action {
    /// Initialize a new project.
    #[clap(name = "new")]
    New {
        /// The name of the newly created project.
        name: String,
        /// The optional target directory for the contract project.
        #[clap(short, long, value_parser)]
        target_dir: Option<PathBuf>,
    },
    /// Compiles the contract.
    #[clap(name = "build")]
    Build,
    /// Converts from the text format to the binary format.
    #[clap(name = "wat2wasm")]
    Wat2Wasm {
        filename: PathBuf,
        /// Output file for the generated wasm file.
        #[clap(short, long, value_parser)]
        output: Option<PathBuf>,
    },
    /// Converts from the binary format to the text format.
    #[clap(name = "wasm2wat")]
    Wasm2Wat {
        filename: PathBuf,
        /// Output file for the generated wat file, by default use stdout.
        #[clap(short, long, value_parser)]
        output: Option<PathBuf>,
    },
}

fn main() -> Result<(), Error> {
    let Cli::We(args) = Cli::parse();

    match args.action {
        Action::New { name, target_dir } => new(name, target_dir),
        Action::Build => build(),
        Action::Wat2Wasm { filename, output } => wat2wasm(filename, output),
        Action::Wasm2Wat { filename, output } => wasm2wat(filename, output),
    }
}

fn new(name: String, target_dir: Option<PathBuf>) -> Result<(), Error> {
    let out_dir = target_dir
        .map_or(env::current_dir()?, |p| {
            <PathBuf as AsRef<Path>>::as_ref(&p).to_path_buf()
        })
        .join(name.clone());
    if out_dir.join("Cargo.toml").exists() {
        println!("A Cargo package already exists in {}", name);
    }
    if !out_dir.exists() {
        fs::create_dir(&out_dir)?;
    }

    let mut cargo_toml = fs::OpenOptions::new()
        .create(true)
        .write(true)
        .truncate(true)
        .open(format!(
            "{}/Cargo.toml",
            out_dir.to_str().expect("Failed to cast to string")
        ))?;

    write!(
        cargo_toml,
        r#"[package]
name = "{}"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = ["cdylib"]
path = "lib.rs"

[profile.release]
codegen-units = 1
lto = true
opt-level = 'z'
panic = 'abort'
strip = true

[dependencies]
we-contract-sdk = {{ version = "0.1.0", path = "../crates/sdk" }}
"#,
        name
    )?;

    let mut lib_rs = fs::OpenOptions::new()
        .create(true)
        .write(true)
        .truncate(true)
        .open(format!(
            "{}/lib.rs",
            out_dir.to_str().expect("Failed to cast to string")
        ))?;

    write!(
        lib_rs,
        r#"#![no_std]
#![no_main]
use we_contract_sdk::*;

#[action]
fn _constructor(init_value: Boolean) {{
    set_storage!(boolean :: "value" => init_value);
}}

#[action]
fn flip() {{
    let value: Boolean = get_storage!(boolean :: "value");
    set_storage!(boolean :: "value" => !value);
}}
"#
    )?;

    let mut gitignore = fs::OpenOptions::new()
        .create(true)
        .write(true)
        .truncate(true)
        .open(format!(
            "{}/.gitignore",
            out_dir.to_str().expect("Failed to cast to string")
        ))?;

    write!(
        gitignore,
        r#"# Generated by Cargo
# will have compiled files and executables
debug/
target/

# Remove Cargo.lock from gitignore if creating an executable, leave it for libraries
# More information here https://doc.rust-lang.org/cargo/guide/cargo-toml-vs-cargo-lock.html
Cargo.lock

# These are backup files generated by rustfmt
**/*.rs.bk

# Used by macOS' file system to track custom attributes of containing folder
.DS_Store

# Editors' specific files
.idea/
.vscode/
"#
    )?;

    println!("Created contract {name}");

    Ok(())
}

fn build() -> Result<(), Error> {
    let mut command = Command::new("cargo")
            .args([
                "+nightly",
                "build",
                "--release",
                "-Zbuild-std=std,panic_abort",
                "--target=wasm32-unknown-unknown",
                "--config=target.wasm32-unknown-unknown.rustflags = [\"-C\", \"target-feature=+bulk-memory,+multivalue\", \"-C\", \"link-args=--no-entry --import-memory -zstack-size=16 --initial-memory=131072 --max-memory=1048576\"]"
            ])
            .stdout(Stdio::piped())
            .spawn()?;

    let reader =
        std::io::BufReader::new(command.stdout.take().expect("Failed to get a read handle"));

    for message in cargo_metadata::Message::parse_stream(reader) {
        match message.expect("Message error") {
            Message::CompilerMessage(msg) => {
                println!("{:?}", msg);
            }
            Message::CompilerArtifact(artifact) => {
                println!("{:?}", artifact);
            }
            Message::BuildScriptExecuted(script) => {
                println!("{:?}", script);
            }
            Message::BuildFinished(finished) => {
                println!("{:?}", finished);
            }
            _ => (),
        }
    }

    command.wait()?;

    Ok(())
}

fn wat2wasm(filename: PathBuf, output: Option<PathBuf>) -> Result<(), Error> {
    let output = match output {
        Some(path) => path
            .as_os_str()
            .to_str()
            .expect("Failed to cast to string")
            .to_string(),
        None => filename
            .clone()
            // .as_os_str()
            .file_name()
            .expect("")
            .to_str()
            .expect("Failed to cast to string")
            .replace(".wat", ".wasm"),
    };

    let binary = wat::parse_file(filename).expect("Failed to parse file");

    let mut file = fs::OpenOptions::new()
        .create(true)
        .write(true)
        .truncate(true)
        .open(output)?;
    let _ = file.write_all(&binary);

    Ok(())
}

fn wasm2wat(filename: PathBuf, output: Option<PathBuf>) -> Result<(), Error> {
    let wat = wasmprinter::print_file(filename).expect("");

    match output {
        Some(path) => {
            let mut file = fs::OpenOptions::new()
                .create(true)
                .write(true)
                .truncate(true)
                .open(path)?;

            let _ = file.write_all(wat.as_bytes());
        }
        None => println!("{}", wat),
    }

    Ok(())
}
